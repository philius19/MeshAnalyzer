# MeshAnalyzer

Python package for quantitative morphology analysis of 3D cell surface reconstructions from fluorescence microscopy. Bridges MATLAB-based mesh generation (u-shape3D) with Python's scientific computing ecosystem.

## Table of Contents

- [Description](#description)
- [Installation](#installation)
- [Quick Start](#quick-start)
- [Pipeline Overview](#pipeline-overview)
- [Data Format](#data-format)
- [Usage Examples](#usage-examples)
- [API Reference](#api-reference)
- [Citation](#citation)
- [Acknowledgments](#acknowledgments)

---

## Description

MeshAnalyzer enables morphological fingerprinting of cells from Lattice Light Sheet Microscopy (LLSM) and other high-resolution 3D imaging modalities. It processes 3D surface meshes generated by MATLAB's u-shape3D framework, providing:

- **Quantitative morphology metrics**: volume, surface area, curvature statistics
- **Time-lapse analysis**: track morphological changes across timepoints with global normalization
- **Automated quality control**: mesh validation, topology checks, orientation correction
- **Visualization**: curvature distributions and spatial maps

**Scientific Context**: Designed for morphological fingerprinting of murine primary myeloid immune cells (neutrophils, macrophages, dendritic cells) to establish cell type-specific morphological signatures.

---

## Installation

### Requirements

- Python 3.10+
- numpy, scipy, matplotlib
- vedo (mesh handling)
- mat73 (MATLAB v7.3 file support)

### Setup

```bash
cd /path/to/Scripts
pip install -e .
```

The `-e` flag installs in editable mode, allowing source modifications without reinstalling.

**Verify installation**:
```bash
python -c "from MeshAnalyzer import load_cell; print('✓ Installation successful')"
```

---

## Quick Start

### Single Frame Analysis

```python
from MeshAnalyzer import load_cell

# Load cell data (recommended entry point)
manager = load_cell('/path/to/cell_directory', channel=1)

# Access specific frame
frame = manager[1]
print(f"Vertices: {frame.n_vertices:,}")
print(f"Volume: {frame.mesh.volume():.2f} voxels³")
```

### Time-Lapse Analysis

```python
from MeshAnalyzer import load_cell

# Load time series
manager = load_cell('/path/to/cell_directory',
                    channel=1,
                    cache_mode='lazy')

# Iterate through time
for time_idx, frame in manager:
    print(f"T{time_idx:02d}: {frame.n_vertices:,} vertices")

# Global normalization
normalized_curv = manager.get_normalized_curvature(method='symmetric')
```

---

## Pipeline Overview

```
MATLAB u-shape3D                       Python MeshAnalyzer
──────────────────                     ───────────────────

Deconvolved TIFF
      ↓
Three-Level Segmentation
 (inside/cell/surface)
      ↓
Marching Cubes (isovalue=0.999)
      ↓
┌─────────────────────┐
│ surface_1_*.mat     │──────────────→  load_cell()
│ meanCurvature_1_*.mat              │         ↓
│ metadata_export.mat │──────────────→  TimeSeriesManager
└─────────────────────┘                         ↓
                                         MeshFrame
                                              ↓
                                    Analysis/Visualization
```

**Key Features**:
- Automatic metadata extraction (pixel sizes, mesh parameters, provenance)
- LRU caching for efficient memory usage in time-lapse
- Robust file format handling (MATLAB v7.3 HDF5 and legacy formats)

---

## Data Format

### Expected Directory Structure

```
cell_directory/
├── *_Decon.mat                    # MovieData file (metadata source)
├── metadata_export.mat            # Python-friendly metadata (optional)
└── Morphology/Analysis/Mesh/ch1/
    ├── surface_1_{t}.mat          # Mesh vertices + faces
    ├── meanCurvature_1_{t}.mat    # Mean curvature per face
    ├── faceNormals_1_{t}.mat      # Face normal vectors (optional)
    ├── gaussCurvatureUnsmoothed_1_{t}.mat  # Gaussian curvature (optional)
    └── imageSurface_1_{t}.mat     # 3D surface mask (optional)
```

### File Contents

**surface_*.mat**:
```matlab
surface (struct)
├── vertices (N × 3 double)   % Vertex coordinates
└── faces (M × 3 double)      % Face indices (1-indexed)
```

**meanCurvature_*.mat**:
```matlab
meanCurvature (M × 1 double)  % Smoothed curvature per face
```

**metadata_export.mat**:
```matlab
metadata (struct)
├── pixel_size_xy_nm (double)      % XY pixel size in nm
├── pixel_size_z_nm (double)       % Z pixel size in nm
├── time_interval_sec (double)     % Time between frames
├── mesh_parameters (struct)       % All u-shape3D parameters
└── source_image_path (string)     % Original TIFF path
```

---

## Usage Examples

### Calculate Morphology Metrics

```python
from MeshAnalyzer import MeshAnalyzer

# Legacy API (still supported)
analyzer = MeshAnalyzer(
    'surface_1_1.mat',
    'meanCurvature_1_1.mat',
    pixel_size_xy=0.103,  # μm
    pixel_size_z=0.217    # μm
)

analyzer.load_data()
results = analyzer.calculate_statistics()

print(f"Volume: {results.mesh_stats.volume_um3:.2f} μm³")
print(f"Surface Area: {results.mesh_stats.surface_area_um2:.2f} μm²")
print(f"Mean Curvature: {results.curvature_stats.mean:.4f} ± {results.curvature_stats.std:.4f}")
```

### Visualize Curvature Distribution

```python
from MeshAnalyzer import plot_curvature_distribution, basic_spatial_plot

# Distribution plots (linear + log scale)
fig = plot_curvature_distribution(
    analyzer.curvature,
    save_path='curvature_dist.pdf'
)

# Spatial curvature map
fig, ax = basic_spatial_plot(
    analyzer.mesh,
    analyzer.curvature,
    title="Membrane Curvature"
)
```

### Batch Processing

```python
from pathlib import Path
import pandas as pd

results = []
for cell_dir in Path('/data/cells').iterdir():
    if not cell_dir.is_dir():
        continue

    try:
        manager = load_cell(cell_dir, channel=1)
        frame = manager[1]  # First timepoint

        results.append({
            'cell_id': cell_dir.name,
            'n_vertices': frame.n_vertices,
            'volume_um3': frame.mesh.volume() * (0.103 ** 3),
            'mean_curvature': frame.curvature.mean()
        })
    except Exception as e:
        print(f"Skipped {cell_dir.name}: {e}")

df = pd.DataFrame(results)
df.to_csv('batch_results.csv', index=False)
```

---

## API Reference

### Main Entry Point

**`load_cell(cell_dir, channel=1, **kwargs)`**

Load mesh data from cell directory (recommended).

Parameters:
- `cell_dir` (str/Path): Path to cell directory
- `channel` (int): Channel number (default: 1)
- `cache_mode` (str): 'none', 'lazy', or 'all' (default: 'lazy')
- `load_auxiliary` (bool): Load auxiliary data (normals, Gaussian curvature)

Returns:
- `TimeSeriesManager` with discovered frames

Example:
```python
manager = load_cell('/path/to/cell', channel=1, cache_mode='lazy')
frame = manager[1]  # Dict-like access by time index
```

### Core Classes

**`TimeSeriesManager`**

Time-lapse manager with LRU caching and global normalization.

Methods:
- `discover_frames()`: Find all timepoints
- `load_frame(time_index)`: Load specific frame
- `validate_frames()`: Check topology consistency
- `get_normalized_curvature()`: Global normalization across time

**`MeshFrame`**

Single timepoint data container.

Attributes:
- `vertices` (np.ndarray): Vertex coordinates (N×3)
- `faces` (np.ndarray): Face indices (M×3)
- `curvature` (np.ndarray): Mean curvature per face (M,)
- `mesh` (vedo.Mesh): 3D mesh object
- `metadata` (ProcessingMetadata): Provenance info

**`MeshAnalyzer`** (Legacy)

Single-frame analyzer (deprecated, use `load_cell()` instead).

Emits `DeprecationWarning`. Migrate to `load_cell()` for new code.

### Visualization

**`plot_curvature_distribution(curvature, save_path=None)`**

Two-panel plot: linear and log scale distributions.

**`basic_spatial_plot(mesh, curvature, save_path=None)`**

Spatial curvature map with symmetric colormap (red=negative, blue=positive).

Returns: `(fig, ax)` tuple

---

## Citation

If MeshAnalyzer supports your research:

```bibtex
@software{meshanalyzer2025,
  title={MeshAnalyzer: Quantitative 3D Morphology Analysis},
  author={Kaintoch, Philipp},
  year={2025},
  version={1.2.0},
  url={https://github.com/your-org/MeshAnalyzer}
}
```

**Note**: Update version and URL when publishing.

---

## Acknowledgments

Built on **u-shape3D** (Danuser Lab, UT Southwestern Medical Center). MeshAnalyzer extends their MATLAB pipeline with Python tools for morphological analysis of immune cells and biological specimens.

**Key References**:
- Vega, F.M. et al. (2018). *u-shape3D: Comprehensive 3D cellular morphometry*.
- Danuser Lab Software: https://www.utsouthwestern.edu/labs/danuser/

---

## License

[Specify license - e.g., MIT, BSD-3-Clause, GPL-3.0]

---

**Version**: 1.2.0
**Last Updated**: December 2025
**Maintainer**: Philipp Kaintoch
